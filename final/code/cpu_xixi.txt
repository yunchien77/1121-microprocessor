LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_UNSIGNED.ALL;
USE work.course8_package.all;


ENTITY CPU IS
 PORT( clk: IN STD_LOGIC;
  data: IN STD_LOGIC_VECTOR(7 DOWNTO 0);
  opcode: IN STD_LOGIC_VECTOR(3 downto 0);
  rs, rt: IN STD_LOGIC_VECTOR(1 DOWNTO 0);
  output: BUFFER std_logic_vector(2 downto 0);
  a0, b0, c0, d0, e0, f0, g0, a1, b1, c1, d1, e1, f1, g1, a2, b2, c2, d2, e2, f2, g2, a3, b3, c3, d3, e3, f3, g3,
  a4, b4, c4, d4, e4, f4, g4, a5, b5, c5, d5, e5, f5, g5: OUT std_logic
  IFetch, ID, EXE, WB: output std_logic;
   );
END CPU;


architecture main of CPU is
  SIGNAL r0, r1, r2, r3: std_logic_vector(7 downto 0);
  signal s, t: std_logic_vector(7 downto 0);
  signal s_temp, t_temp: std_logic_vector(7 downto 0);
  signal q: std_logic_vector(7 downto 0);
  signal op: INTEGER;
  SIGNAL rs_temp, rt_temp: std_logic_vector(7 downto 0);
  signal op_temp: std_logic_vector(3 downto 0);
begin
  divise: diviser PORT MAP(clk,'0', t, s_temp, q);
  IFetch: process
				begin
					wait until clk'event and clk = '1';
					IFetch <= '1';
					
					case opcode is
						when "0000" => 
						  op <= 1;
						when "0001" =>
						  op <= 2;
						when "0010" =>
						  op <= 3;
						when "0011" =>
						  op <= 4;
						when "0100" =>
						  op <= 5;
						when "0101" =>
						  op <= 6;
						when "0110" =>
						  op <= 7;
						when "0111" =>
						  op <= 8;
						when "1111" =>
						  op <= 9;
						when "1000" =>
						  op <= 10;
						when others =>
						  op <= 0;
					 end case;
					 IFetch <= '0';
				END PROCESS;

  IF_ID:
  
  ID: process
			begin
				wait until clk'event and clk = '1';
				ID <= '1';
				with rs select
					s <= r0 when "00",
						  r1 when "01",
						  r2 when "10",
						  r3 when "11";
					
				with rt select 
					t <= r0 when "00",
						  r1 when "01",
				  		  r2 when "10",
						  r3 when "11";
				 ID <= '0';
		END PROCESS;
				
  ID_EXE:
  
  EXE: process
			begin
				wait until clk'event and clk = '1';
				EXE <= '1';
				case op is
            when 0 => 
              s <= data;
            when 1 =>
              s <= t;
            when 2 =>
              s <= s + t;
            when 3 =>
              s <= s - t;
            when 4 =>
              s <= s & t;
            when 5 =>
              s <= s or t;
            when 6 =>
					s <= s nor t;
				when 7 =>
					s <= t;
				when 8 =>
					if   s < t then
						 s <= "00000001";
					else
						 s <= "00000000";
				   end if;
				when 9 =>
              s <= s;
				when 10 =>
					s <= q;
            when others =>
              s <= s;
          end case;
			 EXE <= '0';
		end process;

  EXE_WB: 
  
  WB: process
			begin
				wait until clk'event and clk = '1';
				WB <= '1';
				case rs is
				  when "00" => 
						r0 <= s;
				  when "01" =>
						r1 <= s;
				  when "10" =>
						r2 <= s;
				  when "11" =>
						r3 <= s;
				end case;
				WB <= '0';
			end process;
      

show_rs: seven_segment PORT MAP(s_temp(3), s_temp(2), s_temp(1), s_temp(0), s_temp(7), s_temp(6), s_temp(5), s_temp(4), a1, b1, c1, d1, e1, f1, g1, a0, b0, c0, d0, e0, f0, g0);
show_rt: seven_segment PORT MAP(t(3), t(2), t(1), t(0), t(7), t(6), t(5), t(4), a3, b3, c3, d3, e3, f3, g3, a2, b2, c2, d2, e2, f2, g2);
show_bus: seven_segment PORT MAP(data(3), data(2), data(1), data(0), data(7), data(6), data(5), data(4), a4, b4, c4, d4, e4, f4, g4, a5, b5, c5, d5, e5, f5, g5);
end main;